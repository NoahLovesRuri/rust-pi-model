% cargo run
Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.00s
Running `target/debug/saha_sinha_pi`
Saha–Sinha series with λ=10
π ≈ 3.14159265358979667
terms used: 60
|error|    : 3.553e-15
λ=3    -> π≈3.141592657887732  terms=60  |err|=4.298e-9
λ=5    -> π≈3.141592653642237  terms=60  |err|=5.244e-11
λ=10   -> π≈3.141592653589797  terms=60  |err|=3.553e-15
λ=20   -> π≈3.141592653589794  terms=43  |err|=8.882e-16

---

おお、きれいな数値結果ですね。順に解説します。

---

## 出力の意味

1. **π ≈ 3.14159265358979667**

   * `λ=10` の場合の近似値。
   * Rust の `f64`（倍精度浮動小数点）は約 **15–16 桁** の精度しか扱えません。
   * 出力が「3.14159265358979667」となっていて、既知の π（3.141592653589793…）との差が **3.5×10⁻¹⁵** となっています。
   * これは「f64 が持つ限界精度まで正しく近似できた」ということを意味します。

2. **terms used: 60**

   * 打ち切り上限（60項）まで計算して、十分収束した。
   * ただし実際はもっと少ない項で収束していた可能性が高い。

3. **|error| : 3.553e-15**

   * 真の π との差の絶対値。
   * これは「f64 の丸め誤差レベル」で、理論的にはもっと正確に収束しているが、浮動小数点精度の壁でこれ以上改善できない。

---

## λ ごとの比較

* **λ=3 → 誤差 4.3×10⁻⁹**

  * かなり誤差が大きい。収束がまだ遅い。
* **λ=5 → 誤差 5.2×10⁻¹¹**

  * 改善したが、まだ浮動小数点の限界に到達していない。
* **λ=10 → 誤差 3.6×10⁻¹⁵**

  * f64 の限界まで一致。非常に効率が良い。
* **λ=20 → 誤差 8.9×10⁻¹⁶**

  * さらに少ない項（43項）で、同じくらいの精度に到達。
  * λ を大きくすると項の収束が早まることを示している。

---

## まとめ

* **λ を調整すると収束の速さが変わる**：λ を大きくすると高速に収束し、必要な項数が少なくて済む。
* **f64 の壁**：今回の計算では、π の値はすでに **倍精度の限界**まで到達しており、これ以上精度は上がらない。
* **今後の発展**：より多くの桁を求めたい場合は `rug::Float` などの多倍長ライブラリを使う必要がある。

---

👉 この結果は「Saha–Sinha 級数が少ない項数で高速に π に収束する」ことを、実際に Rust で確認できた例になっています。

次は「rug を導入して、例えば小数点以下 100 桁まで計算する」デモも作ってみますか？

