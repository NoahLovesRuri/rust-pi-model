Rust でこの π 級数（Saha–Sinha の公式）を試すプログラムを書いてみよう。方針を立ててみますね。

---

# 🎯 方針（Rustでの実装）

## 1. 数式の整理

ターゲットの級数は次の形でした：

$$
\pi \;=\; 4 + \sum_{n=1}^\infty \frac{1}{n!} \left( \frac{1}{n + \lambda} - \frac{4}{2n + 1} \right) \left( \frac{(2n+1)^2}{4(n + \lambda)} - n \right)_{n-1}
$$

* $(a)_{m}$ = Pochhammer symbol = $a(a+1)(a+2)...(a+m-1)$
* 実装では `pochhammer(a, m)` を関数化するとわかりやすい。

## 2. 必要な部品

* **階乗 (factorial)** : `n!` を計算（`f64` や `f128` で扱う）。大きな n にはガンマ関数の近似もありだが、まずは小さい n で十分。
* **ポックハマー記号 (pochhammer)** : ループで積を作る関数。
* **収束制御** : 項の大きさが `epsilon` 未満になったら打ち切り。
* **λ の選択** : 例えば λ=10 を試すと収束が速い。

## 3. Rustの構造

* `fn factorial(n: u32) -> f64`
* `fn pochhammer(a: f64, m: u32) -> f64`
* `fn compute_pi(lambda: f64, terms: u32) -> f64`
* `fn main()` で呼び出し、結果を出力。

## 4. 精度管理

* とりあえず `f64`（倍精度浮動小数点）で試す。
* 高精度が欲しければ `rug` クレート（多倍長浮動小数点）を利用。

## 5. 出力と比較

* `std::f64::consts::PI` と比較して、誤差を表示する。
* 繰り返し回数（項数）を増やすと誤差が減っていく様子を確認。

---

👉 この方針で進めれば、まずは **Rust標準ライブラリだけ** で簡単な実装ができます。
**次のステップとして、高精度計算用に `rug` を導入すれば、数百万桁に近い計算も可能になります。**

---

ご希望は「まず Rust 標準ライブラリで簡単なサンプルコード」を見たいですか？ それとも最初から `rug` を使った高精度版がよいですか？

